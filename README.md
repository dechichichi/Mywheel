这里是对STL的简单复现 持续更新中

1.链表
一个链表由一系列节点组成 每个节点有数据项和一个指向下一节点的指针(其实也可以是数组实现)
对于数组实现的链表 插入的耗时为O(N)无法接受
对于指针实现的链表 插入的耗时为O(1)可以接受
链表的基本操作是插入与删除
双向链表 后一节点有指针指向前一节点
循环链表 尾节点的指针指向头节点

2.栈
只允许对栈顶元素进行操作的线性表
分别称为压入与弹出
同样的栈可以用数组或者数组实现
由于栈涉及的元素数量通常较小且对固定元素操作 数组实现不需要创建指针操作 对栈的数组实现有了可利用性

3.队列 
只允许在队尾插入队头删除的线性表
分别称为入队与出队
我们倾向于用数组实现队列
当X入队时 Size++ Rear++ Queue[Rear]=X
当X出队时 Front++ Size-- 返回Queue[Front]
为了节省队列的空间消耗 可以回绕队列 当Front或者Rear到达数组尾端时 回绕到数组开头
使用回绕数组时需要保证同时在队中元素小于数组Size
双端队列允许了队头和队尾进行入队和出队

4.二叉树
每个节点有左右子树和数值
二叉查找树 左子树的节点值小于根节点 右子树的节点值大于根节点 对于每个节点都是如此
这样使得查找的期望时间变成了 O(Log N)

5.AVL树
带有平衡条件的二叉查找树
平衡树:对于每个节点 左右子树的深度差不超过1
为了保证插入后AVL树能保持平衡
我们引入单旋转与双旋转
由于插入的位置不同 分为左单 左双 右单 右双
单旋转以左单为例
根节点K1 K2=K1->left  
此时K1的左子树深度高于右子树 不平衡 称为左重于右
为了平衡 我们加重右
K2->right=k1->right
把k2的right作为新的k1
k2->left=k1
这样旋转一次 左树的深度-- 右树深度++ 达成了平衡

双旋转是对于节点在内部的情况的 
仅仅一次单旋只能把节点放到外面 无法做到减重
故进行二次单旋 达成平衡

6.伸展树
7.B树
上面两种树没有做具体的实现 先跳过
