这里是对STL的简单复现 持续更新中

1.链表
一个链表由一系列节点组成 每个节点有数据项和一个指向下一节点的指针(其实也可以是数组实现)
对于数组实现的链表 插入的耗时为O(N)无法接受
对于指针实现的链表 插入的耗时为O(1)可以接受
链表的基本操作是插入与删除
双向链表 后一节点有指针指向前一节点
循环链表 尾节点的指针指向头节点

2.栈
只允许对栈顶元素进行操作的线性表
分别称为压入与弹出
同样的栈可以用数组或者数组实现
由于栈涉及的元素数量通常较小且对固定元素操作 数组实现不需要创建指针操作 对栈的数组实现有了可利用性

3.队列 
只允许在队尾插入队头删除的线性表
分别称为入队与出队
我们倾向于用数组实现队列
当X入队时 Size++ Rear++ Queue[Rear]=X
当X出队时 Front++ Size-- 返回Queue[Front]
为了节省队列的空间消耗 可以回绕队列 当Front或者Rear到达数组尾端时 回绕到数组开头
使用回绕数组时需要保证同时在队中元素小于数组Size
双端队列允许了队头和队尾进行入队和出队

4.二叉树
每个节点有左右子树和数值
二叉查找树 左子树的节点值小于根节点 右子树的节点值大于根节点 对于每个节点都是如此
这样使得查找的期望时间变成了 O(Log N)

5.AVL树
带有平衡条件的二叉查找树
平衡树:对于每个节点 左右子树的深度差不超过1
为了保证插入后AVL树能保持平衡
我们引入单旋转与双旋转
由于插入的位置不同 分为左单 左双 右单 右双
单旋转以左单为例
根节点K1 K2=K1->left  
此时K1的左子树深度高于右子树 不平衡 称为左重于右
为了平衡 我们加重右
K2->right=k1->right
把k2的right作为新的k1
k2->left=k1
这样旋转一次 左树的深度-- 右树深度++ 达成了平衡

双旋转是对于节点在内部的情况的 
仅仅一次单旋只能把节点放到外面 无法做到减重
故进行二次单旋 达成平衡

6.伸展树
7.B树
上面两种树没有做具体的实现 先跳过
8.散列 跳过

9.堆
堆是一棵被完全填满的树 
有可能的例外在底层 底层上的元素从左到右填入 这样的树叫完全二叉树
二叉堆性质：
堆顶总为最大值或者最小值
对于堆的插入 
在下一空闲位置新建一个节点 若父节点的值不如新节点符合性质 就交换 如此循环 直到不能交换为止

左式堆
零路径:从X到一个没有两个儿子的节点的节点的最短长度  Npl(Null)=-1 
对于堆中每一个节点X 左子树的零路径长至少与右子树的零路径一样长
左式堆的基本操作是合并(插入是合并的特殊情况)
以小根堆为例 
将较大根值的堆与小根值的右子树合并
H1->right=Merge*(H1->right,r2)
若此时右子树的Npl值大于左子树
那么交换左右子树
这种数据结构可以使得合并的时间期望降为O(log N)

